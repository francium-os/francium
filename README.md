# Francium 
This is my hobby operating system - it's a microkernel, vaguely inspired by Nintendo's custom OS for the 3DS/Switch.

It has multiple platform support:
## Hardware support
* x86_64
  * PC
* AArch64
  * QEMU `virt` platform
  * Raspberry Pi 3 (in QEMU, crashes on real hardware)
  * Raspberry Pi 4 (tested on real hardware)

## Device support:
* PCIe - can find a device and map its BARs
  * virtio-blk
  * Bochs virtual video adapter
* Serial
  * Standard PC serial
  * ARM 
* PS/2 (on x86)

## Overview
The crates/ dir has some common functionality and architecture specific (but not kernel specific) functionality factored out into separate modules, so they can be reused elsewhere.
* francium_common - Not much, just some types that need to be shared with userspace.
* francium_drivers - Hardware drivers like interrupt controllers/serial/timers.
* francium_mmu - Generic page table mapping, just define your PTE format.
* francium_aarch64 - AArch64 architecture support, but most lives in the kernel crate still.
* francium_x86 - x86_64 architecture support

The kernel crate `francium` contains most of the functionality.
The platform crates `francium_pc`, `francium_raspi3`, `francium_raspi4`, `francium_virt` have platform specific initialization code, and all depend on the `francium` crate.

Userspace code lives in the `modules` dir, there are many:
* `sm`
  * service manager, responsible for brokering access to the other modules.
* `fs`
  * filesystem - currently doesn't do that much, but it can find a virtio-blk device.
* `pcie`
  * responsible for PCIe devices, used by `fs` and `disp`. Reads ACPI tables or device tree to find the PCIe controller.
* `disp`
  * responsible for displays, shows the splash screen. Talks to RPi firmware, or a Bochs virtual display adapter (via `pcie`).
* `ps2`
  * sets up a PS/2 keyboard and logs keypresses to debug output
* `loader`
  * not implemented yet!
* `net`
  * not implemented yet!
* `test`
  * just a test for `fs` IPC.

`libprocess` wraps the syscall API from the kernel and makes it properly Rust-y. It also provides some of the IPC code - the other half of the IPC code is automatically generated by `ipc-gen-buildtime`, from TOML files in `ipc_definitions` which defines the methods and the inputs/outputs to each method.